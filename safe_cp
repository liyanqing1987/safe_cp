#!/usr/bin/env python3
# -*- coding: utf-8 -*-
################################
# File Name   : safe_cp
# Author      : liyanqing.1987
# Created On  : 2025-11-04 17:30:01
# Description : Safe "cp" script to replace linux "cp" command.
# Version     : V1.0 (2025-11-07)
################################
import os
import re
import sys
import copy
import glob
import json
import socket
import shutil
import datetime
import subprocess

os.environ['PYTHONUNBUFFERED'] = '1'
CURRENT_SCRIPT = sys.argv[0]
CWD = os.getcwd()
HOSTNAME = socket.gethostname()
CURRENT_DATE = datetime.datetime.now().strftime('%Y%m%d')
CURRENT_TIME = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
USER = os.popen('whoami').read().strip()
LOGIN_USER = os.popen('who am i').read().strip()

if LOGIN_USER:
    LOGIN_USER = re.sub(r' .*', '', LOGIN_USER)
else:
    LOGIN_USER = USER


def debug_print(message, debug_level_list=[1, ]):
    """
    Print message based on the debug_level which is specified by environment variable "SAFE_CP_DEBUG".
    [export SAFE_CP_DEBUG=1] : show warning message.
    [export SAFE_CP_DEBUG=2] : show command.
    [export SAFE_CP_DEBUG=3] : show configuration.
    """
    if ('SAFE_CP_DEBUG' in os.environ) and re.match(r'^[123]$', os.environ['SAFE_CP_DEBUG']) and (int(os.environ['SAFE_CP_DEBUG']) in debug_level_list):
        print('\033[1;34m' + str(message) + '\033[0m')


def print_warning(message):
    """
    Print specified message with yellow color.
    """
    print('\033[1;33m' + str(message) + '\033[0m')


class SafeCp():
    """
    Build safe "cp" class with protection/log/alarm machanism.
    -----------
    Protection: Prevent paths in self.protected_path_list from being copied.
    Log: Save logs for all copy operations.
    Alarm: Alarm for copy operation to protected data.
    -----------
    """
    def __init__(self):
        # [Editable] self.protected_path_list : specify protected paths (absolute path), globally effective.
        self.protected_path_list = []

        if 'HOME' in os.environ:
            self.protected_path_list = self.extend_list_with_config(self.protected_path_list, ['/etc/safe_cp.protected', str(os.environ['HOME']) + '/.config/safe_cp.protected'])
        else:
            self.protected_path_list = self.extend_list_with_config(self.protected_path_list, ['/etc/safe_cp.protected'])

        debug_print('[CONFIG] protected_path_list : ' + str(self.protected_path_list), debug_level_list=[3, ])

        # [Editable] self.log_mode : enable the behavior of saving logs.
        # [Editable] self.log_ignore_user_list : specify a user list, will not save logs fro copy operations of users in the list.
        # [Editable] self.log_dir_list : Specify log dir(s) to save log file, make sure permission is "1777".
        self.log_mode = True
        self.log_ignore_user_list = []
        self.log_dir_list = ['/tmp/safe_cp/log']

        if self.log_mode:
            for log_dir in self.log_dir_list:
                if not os.path.exists(log_dir):
                    self.create_dir(log_dir, permission=0o1777)

        debug_print('[CONFIG] log_dir(s) : ' + str(self.log_dir_list), debug_level_list=[3, ])

        # [Editable] self.alarm_command : specify alarm command. ("<TITAL>", "<MESSAGE>" and "<USER>" are replaceable string.")
        # [Editable] self.alarm_ignore_user_list : specify a user list, no alarms will be sent fro copy operations of users in the list.
        self.alarm_command = ''
        self.alarm_ignore_user_list = []
        debug_print('[CONFIG] alarm_command : ' + str(self.alarm_command), debug_level_list=[3, ])

        # [Editable] self.system_cp : specify system cp.
        self.system_cp = '/usr/bin/systemd-cp'

        if not self.system_cp:
            self.get_system_cp()

        debug_print('[CONFIG] system_cp : ' + str(self.system_cp), debug_level_list=[3, ])

        if not self.system_cp:
            debug_print('[WARNING] No system cp is specified.', debug_level_list=[1, 2, 3])
        elif not os.path.exists(self.system_cp):
            debug_print('[WARNING] Specified system cp "' + str(self.system_cp) + '" is missing.', debug_level_list=[1, 2, 3])

    def run_command(self, command, mystdin=subprocess.PIPE, mystdout=subprocess.PIPE, mystderr=subprocess.PIPE, show=False):
        """
        Run system command with subprocess.Popen, get returncode/stdout/stderr.
        """
        SP = subprocess.Popen(command, shell=True, stdin=mystdin, stdout=mystdout, stderr=mystderr)
        (stdout, stderr) = SP.communicate()
        stdout = str(stdout, 'utf-8').strip()
        stderr = str(stderr, 'utf-8').strip()

        if self.system_cp and os.path.exists(self.system_cp):
            stdout = re.sub(self.system_cp, CURRENT_SCRIPT, stdout)
            stderr = re.sub(self.system_cp, CURRENT_SCRIPT, stderr)

        if show:
            if stdout:
                print(stdout)

            if stderr:
                print(stderr)

        return (SP.returncode, stdout, stderr)

    def extend_list_with_config(self, path_list, config_file_list, check_exists=True):
        """
        Extend path_list with config_file(s) on config_file_list.
        """
        # Parse config file(s).
        for config_file in config_file_list:
            if os.path.exists(config_file):
                try:
                    with open(config_file, 'r') as CF:
                        for line in CF.readlines():
                            if (not re.match(r'^\s*$', line)) and (not re.match(r'^\s*#.*$', line)):
                                path_list.append(line)
                except Exception:
                    debug_print('[WARNING] Failed on opening config file ' + str(config_file) + ' for read.', debug_level_list=[1, 2, 3])

        # Process for "~" and "*".
        copy_path_list = copy.deepcopy(path_list)
        tmp_path_list = []

        for path_item in copy_path_list:
            path_item = path_item.strip()

            if re.match(r'^~.*$', path_item) and ('HOME' in os.environ):
                path_item = re.sub(r'~', os.environ['HOME'], path_item)

            if re.search(r'\*', path_item):
                tmp_path_list.extend(glob.glob(path_item))
            else:
                tmp_path_list.append(path_item)

        tmp_path_list = sorted(list(set(tmp_path_list)))

        if not check_exists:
            return tmp_path_list
        else:
            # Get new_path_list with existing path_item.
            new_path_list = []

            for path_item in tmp_path_list:
                if os.path.exists(path_item):
                    new_path_list.append(path_item)

            return new_path_list

    def create_dir(self, dir_path, permission=0o1777):
        """
        Create dir with specified permission.
        """
        if (not os.path.exists(dir_path)) or (not os.path.isdir(dir_path)):
            try:
                debug_print('[COMMAND] mkdir ' + str(dir_path), debug_level_list=[2, 3])
                os.makedirs(dir_path)
                debug_print('[COMMAND] chmod ' + oct(permission)[2:] + ' ' + str(dir_path), debug_level_list=[2, 3])
                os.chmod(dir_path, permission)
            except Exception:
                debug_print('[WARNING] Failed on creating directory ' + str(dir_path) + ' with permission "' + oct(permission)[2:] + '".', debug_level_list=[1, 2, 3])

    def get_system_cp(self):
        """
        Get real system cp is self.system_cp is not specified.
        """
        real_current_script = os.path.realpath(CURRENT_SCRIPT)
        system_cp_list = ['/usr/bin/system_cp', '/usr/bin/cp', '/bin/system_cp', '/bin/cp']

        for system_cp in system_cp_list:
            real_system_cp = os.path.realpath(system_cp)

            if real_system_cp != real_current_script:
                command = '/usr/bin/file --mime ' + str(real_system_cp)
                (return_code, stdout, stderr) = self.run_command(command)

                if ('application/x-executable; charset=binary' in stdout) or ('application/x-sharedlib; charset=binary' in stdout) or ('application/x-mach-binary; charset=binary' in stdout):
                    self.system_cp = real_system_cp
                    break

    def save_log(self, message, message_level='Info'):
        """
        Save message into user log file.
        """
        if self.log_mode and (USER not in self.log_ignore_user_list):
            for log_dir in self.log_dir_list:
                log_user_dir = str(log_dir) + '/' + str(USER)
                self.create_dir(log_user_dir, permission=0o700)
                log_file = str(log_user_dir) + '/' + str(CURRENT_DATE)

                try:
                    with open(log_file, 'a') as LF:
                        log_dic = {"time": CURRENT_TIME, "message_level": message_level, "user": USER, "login_user": LOGIN_USER, "host": HOSTNAME, "cwd": CWD, "message": message}
                        LF.write(str(json.dumps(log_dic, ensure_ascii=False)) + '\n')
                except Exception:
                    debug_print('[WARNING] Failed on saving message into log file "' + str(log_file) + '".', debug_level_list=[1, 2, 3])

    def convert_to_raw_string(self, input_string):
        raw_string = ""

        for char in input_string:
            if char in ['\a', '\b', '\f', '\n', '\r', '\t', '\v', '\'', '\"', '\\', r'(', r')', r' ']:
                raw_string += '\\' + char
            else:
                raw_string += char

        return raw_string

    def parse_cp_command(self):
        """
        Get arguments and paths from cp command.
        """
        cp_command = ' '.join(sys.argv)
        final_cp_command = self.system_cp
        cp_argument_list = []
        cp_source_list = []
        cp_dest = ''

        for i, arg in enumerate(sys.argv[1:]):
            # Process arg.
            if self.system_cp and os.path.exists(self.system_cp):
                arg = self.convert_to_raw_string(arg)

            # Splicing final_cp_command.
            final_cp_command = str(final_cp_command) + ' ' + str(arg)

            # Get cp_argument_list/cp_source_list/cp_dest.
            if re.match(r'^-.+$', arg):
                cp_argument_list.append(arg)
            else:
                if cp_argument_list and (cp_argument_list[-1] == '-t'):
                    if not cp_dest:
                        cp_dest = arg
                    else:
                        cp_source_list.append(arg)
                else:
                    if i == len(sys.argv)-2:
                        if not cp_source_list:
                            cp_source_list.append(arg)
                        else:
                            cp_dest = arg
                    else:
                        cp_source_list.append(arg)

        return cp_command, final_cp_command, cp_argument_list, cp_source_list, cp_dest

    def check_protection(self, copy_path, command):
        """
        Check the copy_path is protected or not.
        """
        if os.path.exists(copy_path):
            absolute_copy_path = os.path.abspath(copy_path)

            for protected_path in self.protected_path_list:
                if re.match(r'^' + str(absolute_copy_path) + '(/.*)?$', protected_path) or re.match(r'^' + str(protected_path) + '(/.*)?$', absolute_copy_path):
                    if absolute_copy_path == protected_path:
                        print_warning('*Warning*: Cannot copy protected path "' + str(copy_path) + '", skip!')
                        self.save_log('*Warning*: Cannot copy protected path "' + str(copy_path) + '", skip!', message_level='Warning')
                    elif re.match(r'^' + str(absolute_copy_path) + '(/.*)?$', protected_path):
                        print_warning('*Warning*: Cannot copy path "' + str(copy_path) + '", there is protected data under it, skip!')
                        self.save_log('*Warning*: Cannot copy path "' + str(copy_path) + '", there is protected data under it, skip!', message_level='Warning')
                    elif re.match(r'^' + str(protected_path) + '(/.*)?$', absolute_copy_path):
                        print_warning('*Warning*: Cannot copy path "' + str(copy_path) + '", it is located under a protected path, skip!')
                        self.save_log('*Warning*: Cannot copy path "' + str(copy_path) + '", it is located under a protected path, skip!', message_level='Warning')

                    if USER == LOGIN_USER:
                        self.send_alarm(message='Time: ' + str(CURRENT_TIME) + '\n User: ' + str(USER) + '\n Host: ' + str(HOSTNAME) + '\n Cwd: ' + str(CWD) + '\n Command: ' + str(command) + '  (skip)')
                    else:
                        self.send_alarm(message='Time: ' + str(CURRENT_TIME) + '\n User: ' + str(USER) + '(' + str(LOGIN_USER) + ')\n Host: ' + str(HOSTNAME) + '\n Cwd: ' + str(CWD) + '\n Command: ' + str(command) + '  (skip)')

                    return True

        return False

    def send_alarm(self, title='', message='', user=''):
        """
        Send alarm message with self.alarm_command.
        """
        if self.alarm_command and (USER not in self.alarm_ignore_user_list):
            if title:
                alarm_command = re.sub(r'<TITLE>', title, self.alarm_command)

            if message:
                alarm_command = re.sub(r'<MESSAGE>', message, self.alarm_command)

            if user:
                alarm_command = re.sub(r'<USER>', user, self.alarm_command)

            debug_print('[COMMAND] ' + str(alarm_command), debug_level_list=[2, 3])
            self.save_log('[alarm_command=' + str(alarm_command) + ']', message_level='Info')
            subprocess.Popen(alarm_command, shell=True)

    def cp(self, cp_source, cp_dest):
        """
        Copy cp_source to cp_dest with python function shutil.copy and shutil.copytree().
        """
        if not os.path.exists(cp_source):
            print(f"cp: cannot stat '{cp_source}': No such file or directory")
        else:
            if os.path.isdir(cp_dest):
                cp_dest = os.path.join(cp_dest, os.path.basename(cp_source))

            if os.path.isfile(cp_source):
                try:
                    shutil.copy(cp_source, cp_dest)
                except PermissionError:
                    print(f'cp: cannot copy "{cp_source}": Permission denied')
                except Exception as err:
                    print(f'cp: failed on copying "{cp_source}": {err}')
            elif os.path.isdir(cp_source):
                try:
                    shutil.copytree(cp_source, cp_dest, dirs_exist_ok=True)
                except PermissionError:
                    print(f'cp: cannot copy "{cp_source}": Permission denied')
                except Exception as err:
                    print(f'cp: failed on copying "{cp_source}": {err}')

    def run(self):
        """
        Main function.
        """
        (cp_command, final_cp_command, cp_argument_list, cp_source_list, cp_dest) = self.parse_cp_command()
        self.save_log('[command=' + str(cp_command) + ']', message_level='Info')

        if (not cp_argument_list) and (not cp_source_list):
            print("cp: missing file operand\nTry 'cp --help' for more information.")
        elif cp_argument_list and (not cp_source_list):
            if self.system_cp and os.path.exists(self.system_cp):
                final_cp_command = str(self.system_cp) + ' ' + str(' '.join(cp_argument_list))
                self.run_command(final_cp_command, show=True)
        else:
            # Check protection.
            is_protected = False

            for cp_source in cp_source_list:
                if self.check_protection(cp_source, cp_command):
                    is_protected = True

            # Execute copy.
            if not is_protected:
                if self.system_cp and os.path.exists(self.system_cp):
                    debug_print('[COMMAND] ' + str(final_cp_command), debug_level_list=[2, 3])
                    self.run_command(final_cp_command, show=True)
                else:
                    debug_print('[COMMAND] cp -rf ' + ' '.join(cp_source_list) + ' ' + str(cp_dest), debug_level_list=[2, 3])

                    if len(cp_source_list) > 1:
                        if not os.path.isdir(cp_dest):
                            print(f"cp: target '{cp_dest}' is not a directory")
                            return

                    for cp_source in cp_source_list:
                        self.cp(cp_source, cp_dest)


################
# Main Process #
################
def main():
    my_safe_cp = SafeCp()
    my_safe_cp.run()


if __name__ == '__main__':
    main()
